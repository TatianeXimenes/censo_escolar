#ğŸ§¬ Algoritmo GenÃ©tico para OtimizaÃ§Ã£o de FunÃ§Ã£o NÃ£o-Linear
## ğŸ“Œ DescriÃ§Ã£o
ImplementaÃ§Ã£o de um Algoritmo GenÃ©tico (AG) em Python para maximizaÃ§Ã£o de uma funÃ§Ã£o matemÃ¡tica nÃ£o-linear. O algoritmo simula o processo de evoluÃ§Ã£o natural com seleÃ§Ã£o, crossover e mutaÃ§Ã£o para encontrar valores Ã³timos que maximizam a funÃ§Ã£o objetivo.

## ğŸ¯ FunÃ§Ã£o Objetivo
Maximizar:
f(x, y) = xÂ² + 3y + 4

Onde:
x âˆˆ [0.0, 51.0]
y âˆˆ [10.0, 51.0]

## ğŸ§© Componentes do Algoritmo
1. RepresentaÃ§Ã£o GenÃ©tica
Cada indivÃ­duo Ã© representado por uma string de bits
8 bits por variÃ¡vel (total 16 bits para x e y)
ConversÃ£o de binÃ¡rio para real no intervalo especificado

2. FunÃ§Ã£o de Fitness
Avalia a qualidade de cada soluÃ§Ã£o
Quanto maior o valor da funÃ§Ã£o, melhor o indivÃ­duo

3. Operadores GenÃ©ticos
SeleÃ§Ã£o por Torneio (k=3): Seleciona os melhores indivÃ­duos
Crossover de Um Ponto: Combina caracterÃ­sticas dos pais
MutaÃ§Ã£o Bit a Bit: Introduz diversidade na populaÃ§Ã£o

4. ParÃ¢metros do AG
n_iter = 150      # NÃºmero de geraÃ§Ãµes
n_populacao = 100 # Tamanho da populaÃ§Ã£o
r_cross = 0.9     # Taxa de crossover (90%)
r_mut = 0.0078    # Taxa de mutaÃ§Ã£o adaptativa

## ğŸ“Š Como Funciona
- InicializaÃ§Ã£o: Gera populaÃ§Ã£o aleatÃ³ria de strings binÃ¡rias
- AvaliaÃ§Ã£o: Calcula fitness para cada indivÃ­duo
- SeleÃ§Ã£o: Escolhe pais via torneio
- ReproduÃ§Ã£o: Aplica crossover e mutaÃ§Ã£o
- SubstituiÃ§Ã£o: Nova geraÃ§Ã£o substitui a anterior
- RepetiÃ§Ã£o: Continua por N geraÃ§Ãµes
- Resultado: Retorna o melhor indivÃ­duo encontrado

## ğŸ“ˆ Resultados
O algoritmo busca o mÃ¡ximo global da funÃ§Ã£o:
- MÃ¡ximo teÃ³rico: f(51, 51) = 51Â² + 3Ã—51 + 4 = 2764
- Algoritmo converge para valores prÃ³ximos do Ã³timo
- VisualizaÃ§Ã£o: Melhoria progressiva ao longo das geraÃ§Ãµes

## ğŸ”§ PersonalizaÃ§Ã£o

- Para Otimizar Outra FunÃ§Ã£o
Modifique a funÃ§Ã£o funcao_de_fitness:
def nova_funcao(x):
    return x[0]**3 + 2*x[1]**2 - 5*x[0]*x[1]

- Para Alterar os Limites
limites = [[-10, 10], [-5, 5], [0, 100]]  # Para 3 variÃ¡veis

- Para Ajustar ParÃ¢metros
n_bits = 16        # Mais precisÃ£o
n_populacao = 200  # Maior diversidade
r_mut = 0.01       # Mais exploraÃ§Ã£o

## ğŸ§ª AplicaÃ§Ãµes PrÃ¡ticas
Este algoritmo pode ser adaptado para:
- OtimizaÃ§Ã£o de parÃ¢metros em modelos ML
- Problemas de roteamento (TSP)
- Projeto de engenharia (minimizaÃ§Ã£o de custos)
- Ajuste de hiperparÃ¢metros de redes neurais

## ğŸ“š ReferÃªncias
Baseado no trabalho de Ankur Chattopadhyay
Conceitos de ComputaÃ§Ã£o EvolucionÃ¡ria
OtimizaÃ§Ã£o HeurÃ­stica e MetaheurÃ­stica

## ğŸ—‚ï¸ Estrutura do CÃ³digo
ag.py
â”œâ”€â”€ funcao_de_fitness()    # FunÃ§Ã£o objetivo
â”œâ”€â”€ bit2real()             # DecodificaÃ§Ã£o binÃ¡ria
â”œâ”€â”€ selection()            # SeleÃ§Ã£o por torneio
â”œâ”€â”€ crossover()            # RecombinaÃ§Ã£o
â”œâ”€â”€ mutacao()             # Operador de mutaÃ§Ã£o
â””â”€â”€ algoritmo_genetico()  # Loop principal


##âš ï¸ ObservaÃ§Ãµes
- O algoritmo maximiza a funÃ§Ã£o (para minimizaÃ§Ã£o, inverter o sinal)
- Taxa de mutaÃ§Ã£o Ã© adaptativa (1/(n_bits Ã— n_variÃ¡veis))
- Elitismo implÃ­cito: Melhor indivÃ­duo Ã© preservado entre geraÃ§Ãµes

## ğŸ”® PossÃ­veis Melhorias
- Elitismo explÃ­cito para garantir preservaÃ§Ã£o do melhor
- Diversas estratÃ©gias de seleÃ§Ã£o (roleta, ranking)
- Tipos de crossover (dois pontos, uniforme)
- VisualizaÃ§Ã£o grÃ¡fica da convergÃªncia
- CritÃ©rios de parada adaptativos



